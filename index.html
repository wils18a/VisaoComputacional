<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Visão Computacional Mobile Estável</title>

<style>
    /* RESET E LAYOUT DE TELA CHEIA */
    html, body {
        height: 100vh; /* Altura total da tela */
        width: 100vw;
        margin: 0;
        padding: 0;
        background-color: #0a0a0a;
        color: #eee;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        flex-direction: column; /* Organiza Header, Conteúdo, Footer verticalmente */
        overflow: hidden; /* Impede rolagem */
    }

    .header {
        flex: 0 0 auto; /* Altura fixa baseada no conteúdo */
        padding: 5px;
        text-align: center;
        background: #111;
    }

    .header h3 { margin: 5px 0; font-size: 1.1rem; }
    .status-msg { color: #ffcc00; font-size: 0.8em; margin: 0;}

    /* ÁREA PRINCIPAL QUE DIVIDE O ESPAÇO */
    .main-layout {
        flex: 1 1 auto; /* Ocupa todo o espaço vertical restante */
        display: flex;
        flex-direction: column;
        width: 100%;
        padding: 5px;
        box-sizing: border-box; /* Garante que padding não aumente o tamanho total */
        gap: 5px;
        overflow: hidden;
    }

    /* CONTAINERS DOS CANVAS (VÍDEO E GRÁFICO) */
    .canvas-container {
        flex: 1 1 0px; /* IMPORTANTE: Divide o espaço igualmente e força altura 0 inicial */
        position: relative;
        background: #000;
        border: 1px solid #333;
        border-radius: 4px;
        overflow: hidden;
        width: 100%;
        display: flex; /* Para centralizar o canvas dentro */
        justify-content: center;
        align-items: center;
    }

    /* O canvas deve tentar preencher o container mantendo a proporção */
    canvas {
        display: block;
        /* 'contain' garante que vemos tudo sem distorção, pode gerar barras pretas */
        object-fit: contain; 
        max-width: 100%;
        max-height: 100%;
    }

    /* Vídeo escondido mas ativo */
    #videoInput {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        object-fit: cover; z-index: -1; opacity: 0;
    }

    .label-overlay {
        position: absolute; top: 5px; left: 5px;
        background: rgba(0,0,0,0.5); padding: 2px 6px;
        border-radius: 4px; font-size: 10px; pointer-events: none; z-index: 10;
    }

    /* RODAPÉ */
    .footer-info {
        flex: 0 0 auto;
        padding: 5px;
        text-align: center;
        background: #111;
        font-size: 0.9em;
    }
    #coords-display { color: #00ff00; font-weight: bold; }
</style>
</head>

<body>

<div class="header">
    <h3>Detector de Círculos (Estável)</h3>
    <div id="status" class="status-msg">Carregando OpenCV.js...</div>
</div>

<div class="main-layout">
    <div class="canvas-container">
        <div class="label-overlay">Câmera (Processada)</div>
        <video id="videoInput" playsinline webkit-playsinline muted></video>
        <canvas id="canvasOutput"></canvas>
    </div>

    <div class="canvas-container">
        <div class="label-overlay">Trajetória (4s)</div>
        <canvas id="graphCanvas"></canvas>
    </div>
</div>

<div class="footer-info">
    Posição: <span id="coords-display">Aguardando...</span>
</div>

<script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady();"></script>

<script>
let video = document.getElementById('videoInput');
let canvasOutput = document.getElementById('canvasOutput');
let graphCanvas = document.getElementById('graphCanvas');
let ctxGraph = graphCanvas.getContext('2d');
let coordsDisplay = document.getElementById('coords-display');
let status = document.getElementById('status');

let src, gray, circles, cap;
let streaming = false;

// AJUSTE DE ESTABILIDADE 1: Média móvel maior
// Aumentado de 3 para 6 para movimentos mais suaves
let historyX = [];
let historyY = [];
const MOVING_AVG_SIZE = 6; 

let lastPosX = null;
let lastPosY = null;
let lastResetTime = Date.now();

function onOpenCvReady() {
    status.innerHTML = "OpenCV Pronto. Iniciando câmera...";
    startCamera();
}

function startCamera() {
    const constraints = {
        video: {
            facingMode: "environment",
            width: { ideal: 640 },
            height: { ideal: 480 }
        },
        audio: false
    };

    navigator.mediaDevices.getUserMedia(constraints)
    .then(stream => {
        video.srcObject = stream;
        video.play().catch(e => console.error("Erro play:", e));
    })
    .catch(err => {
        status.innerHTML = "Erro Câmera: " + err.name + ". Use HTTPS.";
        console.error(err);
    });

    video.addEventListener("playing", () => {
        if (!streaming) initProcessor();
    });
}

function initProcessor() {
    if (video.videoWidth === 0) {
        setTimeout(initProcessor, 100);
        return;
    }

    const w = video.videoWidth;
    const h = video.videoHeight;

    // Define tamanho interno dos elementos baseado na fonte de vídeo
    video.width = w; video.height = h;
    canvasOutput.width = w; canvasOutput.height = h;
    // O gráfico também usa a mesma resolução interna da câmera
    graphCanvas.width = w; graphCanvas.height = h;

    src = new cv.Mat(h, w, cv.CV_8UC4);
    gray = new cv.Mat(h, w, cv.CV_8UC1);
    circles = new cv.Mat();
    cap = new cv.VideoCapture(video);

    clearGraph();
    streaming = true;
    
    status.innerHTML = `Ativo: ${w}x${h} | Média: ${MOVING_AVG_SIZE} frames`;
    status.style.color = "#00ff00";

    requestAnimationFrame(processFrame);
}

function clearGraph() {
    ctxGraph.fillStyle = "#111";
    ctxGraph.fillRect(0, 0, graphCanvas.width, graphCanvas.height);
    
    ctxGraph.strokeStyle = "#333";
    ctxGraph.lineWidth = 1;
    // Grid ajustado para a resolução interna
    const stepX = graphCanvas.width / 8;
    const stepY = graphCanvas.height / 6;

    ctxGraph.beginPath();
    for (let i = stepX; i < graphCanvas.width; i += stepX) {
        ctxGraph.moveTo(i, 0); ctxGraph.lineTo(i, graphCanvas.height);
    }
    for (let i = stepY; i < graphCanvas.height; i += stepY) {
        ctxGraph.moveTo(0, i); ctxGraph.lineTo(graphCanvas.width, i);
    }
    ctxGraph.stroke();

    lastPosX = null;
    lastPosY = null;
}

function processFrame() {
    if (!streaming) return;

    try {
        cap.read(src);
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
        
        // AJUSTE DE ESTABILIDADE 2: Blur maior
        // Aumentado de 5 para 7 para reduzir ruído de textura
        cv.medianBlur(gray, gray, 7); 

        // AJUSTE DE ESTABILIDADE 3: Parâmetros de Hough mais rigorosos
        cv.HoughCircles(
            gray, circles,
            cv.HOUGH_GRADIENT,
            1.2, // dp (resolução do acumulador)
            100, // minDist (distância mínima entre centros)
            150, // param1 (Limiar superior do Canny edge detector) -> Aumentado para filtrar arestas fracas
            55,  // param2 (Limiar do acumulador) -> AUMENTADO SIGNIFICATIVAMENTE (era 35). Define quão "perfeito" o círculo deve ser.
            10, 200 // MinRadius, MaxRadius (ajuste conforme o tamanho do objeto real)
        );

        cv.imshow("canvasOutput", src);
        let ctxVideo = canvasOutput.getContext("2d");
        
        if (circles.cols > 0) {
            // Pega apenas o primeiro círculo detectado (o mais forte)
            let rawX = circles.data32F[0];
            let rawY = circles.data32F[1];
            let radius = circles.data32F[2];

            // Aplica Média Móvel
            historyX.push(rawX);
            historyY.push(rawY);
            if (historyX.length > MOVING_AVG_SIZE) {
                historyX.shift();
                historyY.shift();
            }

            let avgX = historyX.reduce((a, b) => a + b) / historyX.length;
            let avgY = historyY.reduce((a, b) => a + b) / historyY.length;

            // Desenha no vídeo
            ctxVideo.beginPath();
            ctxVideo.arc(avgX, avgY, radius, 0, Math.PI * 2);
            ctxVideo.strokeStyle = "#00ff00";
            ctxVideo.lineWidth = 3;
            ctxVideo.stroke();
            ctxVideo.fillStyle = "red";
            ctxVideo.fillRect(avgX - 4, avgY - 4, 8, 8);

            // Desenha na trajetória
            if (lastPosX !== null) {
                ctxGraph.beginPath();
                ctxGraph.moveTo(lastPosX, lastPosY);
                ctxGraph.lineTo(avgX, avgY);
                ctxGraph.strokeStyle = "cyan"; // Cor da linha mais visível
                ctxGraph.lineWidth = 2;
                ctxGraph.stroke();
            }
            lastPosX = avgX;
            lastPosY = avgY;
            coordsDisplay.innerHTML = `X: ${Math.round(avgX)} | Y: ${Math.round(avgY)}`;
        } else {
            coordsDisplay.innerHTML = "Nenhum círculo detectado";
             // Opcional: Se perder a detecção, reseta a média móvel para evitar "pulo" quando voltar
             if(historyX.length > 0 && Date.now() - lastResetTime > 500) {
                 historyX = []; historyY = []; lastPosX = null;
             }
        }

        // Limpa o gráfico a cada 4 segundos
        if (Date.now() - lastResetTime > 4000) {
            clearGraph();
            lastResetTime = Date.now();
        }

        requestAnimationFrame(processFrame);

    } catch (e) {
        console.error("Erro processamento:", e);
        requestAnimationFrame(processFrame);
    }
}
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Detector OpenCV Mobile Fix</title>

<style>
    body {
        margin: 0;
        background-color: #0a0a0a;
        color: #eee;
        font-family: sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    .main-layout {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
        padding: 10px;
        width: 100%;
    }

    .canvas-container {
        position: relative;
        background: #000;
        border: 2px solid #444;
        border-radius: 8px;
        overflow: hidden;
        width: 95%;
        max-width: 640px;
    }

    canvas {
        width: 100%;
        height: auto;
        display: block;
    }

    /* VÍDEO PRECISA ESTAR "VISÍVEL" PARA O NAVEGADOR CONTINUAR PROCESSANDO */
    #videoInput {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0.01; /* Quase invisível, mas tecnicamente renderizado */
        pointer-events: none;
        z-index: -1;
    }

    .label-overlay {
        position: absolute;
        top: 5px;
        left: 5px;
        background: rgba(0,0,0,0.6);
        padding: 4px 8px;
        font-size: 12px;
        border-radius: 4px;
        z-index: 5;
    }

    #status {
        color: #ffcc00;
        padding: 10px;
        font-size: 14px;
        text-align: center;
    }

    #coords-display {
        color: #00ff00;
        font-weight: bold;
        margin: 10px;
    }
</style>
</head>

<body>

<div id="status">Carregando bibliotecas...</div>

<div class="main-layout">
    <div class="canvas-container">
        <div class="label-overlay">Câmera em Tempo Real</div>
        <video id="videoInput" autoplay muted playsinline></video>
        <canvas id="canvasOutput"></canvas>
    </div>

    <div class="canvas-container">
        <div class="label-overlay">Trajetória (4s)</div>
        <canvas id="graphCanvas"></canvas>
    </div>
</div>

<div id="coords-display">Aguardando detecção...</div>

<script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady();"></script>

<script>
let video = document.getElementById('videoInput');
let canvasOutput = document.getElementById('canvasOutput');
let graphCanvas = document.getElementById('graphCanvas');
let ctxGraph = graphCanvas.getContext('2d');
let status = document.getElementById('status');

let src, gray, circles, cap;
let streaming = false;

// Configurações de suavização
let historyX = [], historyY = [];
const AVG_SIZE = 3;
let lastPosX = null, lastPosY = null;
let lastReset = Date.now();

function onOpenCvReady() {
    status.innerHTML = "OpenCV Pronto. Acessando câmera...";
    startCamera();
}

function startCamera() {
    const constraints = {
        video: { 
            facingMode: "environment",
            width: { ideal: 640 },
            height: { ideal: 480 }
        },
        audio: false
    };

    navigator.mediaDevices.getUserMedia(constraints)
    .then(stream => {
        video.srcObject = stream;
        video.setAttribute("playsinline", true); // Fix extra para iOS
        video.play();
        
        // Verifica se o vídeo realmente começou a enviar frames
        video.addEventListener("canplay", () => {
            if (!streaming) {
                setTimeout(initProcessor, 1000); // Delay curto para estabilizar sensor
            }
        });
    })
    .catch(err => {
        status.innerHTML = "Erro na câmera: " + err.name;
        status.style.color = "red";
    });
}

function initProcessor() {
    if (video.videoWidth === 0) {
        setTimeout(initProcessor, 500);
        return;
    }

    const w = video.videoWidth;
    const h = video.videoHeight;

    canvasOutput.width = w;
    canvasOutput.height = h;
    graphCanvas.width = w;
    graphCanvas.height = h;

    src = new cv.Mat(h, w, cv.CV_8UC4);
    gray = new cv.Mat(h, w, cv.CV_8UC1);
    circles = new cv.Mat();
    cap = new cv.VideoCapture(video);

    clearGraph();
    streaming = true;
    status.innerHTML = "SISTEMA ATIVO";
    status.style.color = "#00ff00";
    
    processFrame();
}

function clearGraph() {
    ctxGraph.fillStyle = "#111";
    ctxGraph.fillRect(0, 0, graphCanvas.width, graphCanvas.height);
    lastPosX = null; lastPosY = null;
}

function processFrame() {
    if (!streaming) return;

    try {
        // SÓ processa se o vídeo tiver frames prontos (evita tela preta)
        if (video.readyState === video.HAVE_ENOUGH_DATA) {
            cap.read(src);
            
            // 1. Converter para cinza e aplicar desfoque para performance
            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
            cv.GaussianBlur(gray, gray, new cv.Size(7, 7), 1.5, 1.5);

            // 2. Mostrar o frame original no canvas de saída
            cv.imshow("canvasOutput", src);

            // 3. Detecção de círculos
            cv.HoughCircles(
                gray, circles,
                cv.HOUGH_GRADIENT,
                1.5,  // dp
                60,   // minDist
                75,   // param1
                40,   // param2
                15, 120 // min/max radius
            );

            if (circles.cols > 0) {
                let x = circles.data32F[0];
                let y = circles.data32F[1];
                let r = circles.data32F[2];

                // Média móvel para estabilizar
                historyX.push(x); historyY.push(y);
                if(historyX.length > AVG_SIZE) { historyX.shift(); historyY.shift(); }
                
                let avgX = historyX.reduce((a,b)=>a+b)/historyX.length;
                let avgY = historyY.reduce((a,b)=>a+b)/historyY.length;

                // Desenhar no canvas principal
                let ctx = canvasOutput.getContext('2d');
                ctx.strokeStyle = "#00ff00";
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(avgX, avgY, r, 0, Math.PI*2);
                ctx.stroke();

                // Desenhar Trajetória
                if (lastPosX !== null) {
                    ctxGraph.strokeStyle = "red";
                    ctxGraph.lineWidth = 2;
                    ctxGraph.beginPath();
                    ctxGraph.moveTo(lastPosX, lastPosY);
                    ctxGraph.lineTo(avgX, avgY);
                    ctxGraph.stroke();
                }
                lastPosX = avgX; lastPosY = avgY;
                document.getElementById('coords-display').innerHTML = `X: ${Math.round(avgX)} Y: ${Math.round(avgY)}`;
            }
        }

        // Auto-reset do gráfico
        if (Date.now() - lastReset > 4000) {
            clearGraph();
            lastReset = Date.now();
        }

        requestAnimationFrame(processFrame);
    } catch (e) {
        console.error("Erro no loop:", e);
        setTimeout(processFrame, 1000); // Tenta reiniciar em 1s se falhar
    }
}
</script>

</body>
</html>

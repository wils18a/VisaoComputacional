<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Visão Computacional Mobile</title>

<style>
    body {
        margin: 0;
        background-color: #000;
        color: #eee;
        font-family: sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        overflow: hidden; /* Evita rolagem no mobile */
    }

    /* Botão de Início Manual (Obrigatório para iOS/Android Chrome modernos) */
    #start-btn {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 20px 40px;
        background: #00ff00;
        color: #000;
        font-size: 20px;
        font-weight: bold;
        border: none;
        border-radius: 10px;
        z-index: 9999;
        cursor: pointer;
        box-shadow: 0 0 20px rgba(0,255,0,0.5);
    }

    .main-layout {
        position: relative;
        width: 100vw;
        height: 100vh;
        display: flex;
        flex-direction: column;
    }

    .canvas-wrapper {
        position: relative;
        width: 100%;
        flex: 1;
        background: #111;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden;
    }

    /* O vídeo precisa existir no DOM, mas fora da visão imediata */
    #videoInput {
        position: absolute;
        top: -9999px;
        left: -9999px;
        visibility: visible; /* Não use display: none */
    }

    canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: contain;
    }

    #graphCanvas {
        pointer-events: none; /* Deixa cliques passarem */
        z-index: 2;
        background: transparent;
    }

    #canvasOutput {
        z-index: 1;
    }

    .ui-layer {
        position: absolute;
        bottom: 20px;
        left: 0;
        width: 100%;
        text-align: center;
        z-index: 10;
        pointer-events: none;
        text-shadow: 1px 1px 2px black;
    }

    #coords {
        font-size: 1.2rem;
        color: #0f0;
        font-weight: bold;
    }

    #status {
        font-size: 0.9rem;
        color: #ffcc00;
        margin-bottom: 5px;
    }
</style>
</head>

<body>

<button id="start-btn" onclick="startApp()">INICIAR CÂMERA</button>

<video id="videoInput" playsinline webkit-playsinline muted></video>

<div class="main-layout">
    <div class="canvas-wrapper">
        <canvas id="canvasOutput"></canvas>
        <canvas id="graphCanvas"></canvas>
    </div>

    <div class="ui-layer">
        <div id="status">Aguardando início...</div>
        <div id="coords">Toque em INICIAR</div>
    </div>
</div>

<script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady();"></script>

<script>
let video = document.getElementById('videoInput');
let canvasOutput = document.getElementById('canvasOutput');
let graphCanvas = document.getElementById('graphCanvas');
let ctxGraph = graphCanvas.getContext('2d');
let statusDisplay = document.getElementById('status');
let coordsDisplay = document.getElementById('coords');
let startBtn = document.getElementById('start-btn');

let stream = null;
let cap = null;
let src = null;
let gray = null;
let circles = null;
let streaming = false;
let opencvLoaded = false;

// Variáveis de Lógica
let historyX = [], historyY = [];
const AVG_SIZE = 4;
let lastPosX = null, lastPosY = null;
let lastResetTime = Date.now();

function onOpenCvReady() {
    opencvLoaded = true;
    statusDisplay.innerHTML = "OpenCV Carregado. Toque em INICIAR.";
}

function startApp() {
    if (!opencvLoaded) {
        alert("Aguarde o OpenCV carregar totalmente.");
        return;
    }
    startBtn.style.display = 'none';
    startCamera();
}

function startCamera() {
    statusDisplay.innerHTML = "Solicitando Câmera...";
    
    // Configuração robusta para mobile
    const constraints = {
        audio: false,
        video: {
            facingMode: 'environment', // Tenta câmera traseira
            width: { ideal: 640 },     // Resolução segura
            height: { ideal: 480 }
        }
    };

    navigator.mediaDevices.getUserMedia(constraints)
        .then(s => {
            stream = s;
            video.srcObject = stream;
            video.play().then(() => {
                // Só iniciamos o processamento quando o vídeo estiver realmente rodando
                waitForVideoDimensions();
            });
        })
        .catch(err => {
            statusDisplay.innerHTML = "Erro Câmera: " + err;
            startBtn.style.display = 'block'; // Devolve o botão se der erro
            console.error(err);
        });
}

// CORREÇÃO CRÍTICA: Loop que espera o vídeo ter tamanho > 0
function waitForVideoDimensions() {
    statusDisplay.innerHTML = "Aguardando frames...";
    
    const checkInterval = setInterval(() => {
        if (video.videoWidth > 0 && video.videoHeight > 0) {
            clearInterval(checkInterval);
            initOpenCV();
        }
    }, 100);
}

function initOpenCV() {
    const w = video.videoWidth;
    const h = video.videoHeight;

    // Ajusta tamanho interno dos canvas para bater com a resolução real da câmera
    canvasOutput.width = w;
    canvasOutput.height = h;
    graphCanvas.width = w;
    graphCanvas.height = h;

    // Inicializa Matrizes
    try {
        cap = new cv.VideoCapture(video);
        src = new cv.Mat(h, w, cv.CV_8UC4);
        gray = new cv.Mat(h, w, cv.CV_8UC1);
        circles = new cv.Mat();
        
        streaming = true;
        statusDisplay.innerHTML = "SISTEMA ONLINE";
        statusDisplay.style.color = "#00ff00";
        
        clearGraph();
        requestAnimationFrame(processFrame);
    } catch (err) {
        statusDisplay.innerHTML = "Erro init OpenCV: " + err;
        console.error(err);
    }
}

function clearGraph() {
    ctxGraph.clearRect(0, 0, graphCanvas.width, graphCanvas.height);
    lastPosX = null;
    lastPosY = null;
}

function processFrame() {
    if (!streaming) return;

    try {
        // Verifica se o vídeo está pausado ou finalizado
        if (video.paused || video.ended) {
            requestAnimationFrame(processFrame);
            return;
        }

        cap.read(src);
        
        // --- Processamento ---
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
        
        // Blur mais leve para celular (kernel 5x5)
        cv.GaussianBlur(gray, gray, new cv.Size(5, 5), 0);

        // Parâmetros ajustados para objetos genéricos em celular
        cv.HoughCircles(
            gray, circles,
            cv.HOUGH_GRADIENT,
            1.5,  // dp (resolução)
            50,   // minDist (distância entre círculos)
            80,   // param1 (canny threshold)
            40,   // param2 (accumulator threshold - menor detecta mais)
            10, 150 // min/max radius
        );

        // Desenha imagem da câmera
        cv.imshow('canvasOutput', src);

        // Desenha detecções
        if (circles.cols > 0) {
            const x = circles.data32F[0];
            const y = circles.data32F[1];
            const r = circles.data32F[2];

            // Média Móvel
            historyX.push(x);
            historyY.push(y);
            if (historyX.length > AVG_SIZE) { historyX.shift(); historyY.shift(); }
            
            const avgX = historyX.reduce((a,b)=>a+b)/historyX.length;
            const avgY = historyY.reduce((a,b)=>a+b)/historyY.length;

            // Visualização
            const ctx = canvasOutput.getContext('2d');
            ctx.beginPath();
            ctx.arc(avgX, avgY, r, 0, 2 * Math.PI);
            ctx.strokeStyle = 'lime';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Rastro
            if (lastPosX !== null) {
                ctxGraph.beginPath();
                ctxGraph.moveTo(lastPosX, lastPosY);
                ctxGraph.lineTo(avgX, avgY);
                ctxGraph.strokeStyle = 'red';
                ctxGraph.lineWidth = 4;
                ctxGraph.lineCap = 'round';
                ctxGraph.stroke();
            }

            lastPosX = avgX;
            lastPosY = avgY;
            coordsDisplay.innerHTML = `X: ${Math.round(avgX)} Y: ${Math.round(avgY)}`;
        } else {
            coordsDisplay.innerHTML = "Procurando...";
        }

        // Limpeza automática a cada 4s
        if (Date.now() - lastResetTime > 4000) {
            clearGraph();
            lastResetTime = Date.now();
        }

        requestAnimationFrame(processFrame);

    } catch (err) {
        console.error("Erro loop:", err);
        // Tenta recuperar no próximo frame
        requestAnimationFrame(processFrame);
    }
}
</script>

</body>
</html>
